var ALPHA = 10

/// DECISION PROBLEM: possible worlds, actions, and
var possibleWorlds =
    Categorical({
        ps:[.8, .1, .1],
        vs: ['does not exist', 'exists - closed', 'exists - open']
    })

var actions = ['gas', 'wait']

/// R(a, w)
var marginalReward = function(a, worlds) {

    return expectation(worlds, function(w) {

        // getting gas is great if it's open, bad otherwise
        if (a === 'gas') {
            if (w === 'exists - open') {return 1}
            return -1
        }

        // default of waiting is bad, but not *as* bad.
        return -.5

    })

}

/// Utterances and p(w | u)
var utterances =  Infer({method: 'enumerate'}, function(){
    uniformDraw(['sorry', 'exists', 'exists - open', 'exists - closed'])
})

var literalMeanings = {

    // No information about the world.
    'sorry': function(world) { return world; },

    // Specify exact world state.
    'exists - open': function(world) { return world === 'exists - open'; },
    'exists - closed': function(world) { return world === 'exists - closed'; },

    // Ambiguous about world state.
    'exists': function(world) {
        return (world === 'exists - closed') || (world === 'exists - open');
    }
};

/// Assume longer utterances are more expensive.
var uttCost = function(utt){

    return 0

}

///fold:
var beliefListener = function(utt) {
    return Infer({method: 'enumerate'}, function(){

        // Sample from all worlds
        var world = sample(possibleWorlds)
        var meaning = literalMeanings[utt];
        condition(meaning(world));

        return world
    })
}

var actionListener = function(utt) {

    var beliefs = beliefListener(utt)

    return Infer({method: 'enumerate'}, function(){

        var actionChoice = uniformDraw(actions)
        factor(ALPHA * marginalReward(actionChoice, beliefs))

        return actionChoice
    })
}

var truthFunc = function(utt, trueWorld){

    var worldLogProb = beliefListener(utt).score(trueWorld)

//     Use actual world uncertainty
//     return Math.max(worldLogProb, -5000)

    // Use +1 / -1 heuristic
    return (worldLogProb === -Infinity) ? -1 : 1

}

var speaker = function(trueWorld, lambda){

    return Infer({method: 'enumerate'}, function(){

        var utt = sample(utterances)
        var action = sample(actionListener(utt))
        var actionUtility = marginalReward(action, Categorical({ps:[1], vs:[trueWorld]}))
        var truthUtility = truthFunc(utt, trueWorld)

        var uttUtility = lambda * actionUtility + (1-lambda)*truthUtility - uttCost(utt)
        factor(ALPHA * uttUtility)

        return utt
    })

}
///

var pragmaticListener = function(utt, lambda){

    return Infer({method: 'enumerate'}, function(){

        var world = sample(possibleWorlds)
        var speakerUtt = sample(speaker(world, lambda))
        condition(speakerUtt === utt)

        return world

    })

}



viz(beliefListener('sorry'))
// viz(actionListener('sorry'))
// viz(actionListener('exists'))

// viz(speaker('exists - open', 0))
// viz(speaker('exists - open', .5))
// viz(speaker('exists - open', 1))

viz(pragmaticListener('exists', 0))
viz(pragmaticListener('exists', .5))
viz(pragmaticListener('exists', 1))