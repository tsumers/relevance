//////// Setup: Possible worlds, literal meanings ////////

var times = [0, 1, 2, 3, 4, 5]

var possibleWorlds =
    Categorical({
        ps: repeat(times.length, function(){
            return 1/times.length
        }),
        vs: times
    })

var rounded = function(t) {
    return Math.round(t / 5) * 5;
}

var literalMeanings = function(t) {
    return function(trueWorld) {
        return t === trueWorld
    }
};

//////// Utterance utilities and costs ////////

// Decision-theoretic utility of an utterance for control condition
var actionValueRegular = function(utt, trueWorld) {

    // If the true time rounds to the given time, we're fine
    if (rounded(trueWorld) === rounded(utt)){
        return 1
    }
    // Otherwise, bad.
    return -1

}

// Decision-theoretic utility of an utterance for watch-setting condition
var actionValueWatchSetting = function(utt, trueWorld) {

    var minutesOff = Math.abs(utt - trueWorld)

    // We lose a quarter point of utility for every minute we're off.
    return 1 - minutesOff / 4

}

// Unrounded times are more expensive.
var uttCost = function(utt){

    if (rounded(utt) === utt){
        return .5
    }
    return 1

}

// Truth value is +1 / -1
var uttTruth = function(utt, world) {

    if (utt === world) {return 1}
    return -1

}

//////// Speakers and Listeners ////////
var beliefListener = function(utt) {
    return Infer({method: 'enumerate'}, function(){

        // Sample from all worlds
        var world = sample(possibleWorlds)
        var meaning = literalMeanings(utt);
        condition(meaning(world));

        return world
    })
}

var actionListener = function(utt, actionValueFunction, alpha) {

    var beliefs = beliefListener(utt)
    return Infer({method: 'enumerate'}, function(){

        var actionChoice = uniformDraw(times)
        factor(alpha * expectation(beliefs, function(world){
            return actionValueFunction(actionChoice, world)
        }));

        return actionChoice
    })
}

var speaker = function(trueWorld, actionValueFunction, lambda, alpha){

    return Infer({method: 'enumerate'}, function(){

        var utt = sample(possibleWorlds)
        var actionUtility = expectation(actionListener(utt, actionValueFunction, alpha), function(a){
            return actionValueFunction(a, trueWorld)
        })

        var uttUtility = lambda * actionUtility + (1-lambda)*uttTruth(utt, time) - uttCost(utt)
        factor(alpha * uttUtility)

        return utt
    })

}

//////// Grid Search over parameters ////////
// See notebook: webppl-analysis.ipynb to launch this script
// Runs a search over parameters

var speakerWrapper = function(params){

    var results = speaker(params.time, params.actionValueFunction, params.lambda, params.alpha)
    return extend(params, {'results': results})

}

var gridSearchParams = function(actionValueFunction){
    return Infer({method: 'enumerate'}, function(){
        return {
            'alpha': uniformDraw([10]),
            'time': uniformDraw([0, 1, 2, 3, 4]),
            'lambda': uniformDraw(_.range(0, 1.05, .05)),
            'actionValueFunction': uniformDraw([actionValueFunction])
        }
    }).support()
}

/// Run parameter sweep for analysis
var normalGridResults = mapData({'data': gridSearchParams(actionValueRegular)}, speakerWrapper)
json.write('ex3-results-regular.json', normalGridResults);

var watchSettingGridResults = mapData({'data': gridSearchParams(actionValueWatchSetting)}, speakerWrapper)
json.write('ex3-results-watch-setting.json', watchSettingGridResults);

// OR comment the above out, and uncomment this to run in browser
// var time = 3
// var lambda = .9
// var alpha = 10
// console.log(JSON.stringify(speaker(time, actionValueRegular, lambda, alpha)))
// console.log(JSON.stringify(speaker(time, actionValueWatchSetting, lambda, alpha)))
